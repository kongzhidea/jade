/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. sql\MysqlParser.jj */
/*@egen*/options {
	JDK_VERSION = "1.5";
	IGNORE_CASE=true ;
	DEBUG_PARSER=false ;
   	                               
   	                    
   	                     
   	             
	                 
	                         
   	STATIC = false;
}

PARSER_BEGIN(MysqlParser)

/*
 * Copyright (C) 2008 Struct chen <piratebase@sina.com>
 * 	This program is free software; you can redistribute it and/or modify it under the terms of 
 * the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, 
 * or (at your option) any later version. 
 * 
 * 	This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details. 
 * 	You should have received a copy of the GNU General Public License along with this program; 
 * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package com.meidusa.amoeba.mysql.parser.sql;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

import com.meidusa.amoeba.parser.dbobject.*;
import com.meidusa.amoeba.parser.expression.*;
import com.meidusa.amoeba.parser.function.*;
import com.meidusa.amoeba.parser.Parser;
import com.meidusa.amoeba.parser.statment.*;

import java.math.BigDecimal;
import java.util.Map;
import java.util.HashMap;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Calendar;

import java.sql.Connection;
import com.meidusa.amoeba.sqljep.function.Comparative;

public class MysqlParser implements/*@bgen(jjtree)*/ MysqlParserTreeConstants, /*@egen*/ com.meidusa.amoeba.parser.Parser{/*@bgen(jjtree)*/
  protected JJTMysqlParserState jjtree = new JJTMysqlParserState();

/*@egen*/
	private final static String metachars = "tnrbf\\\"";
	private final static String chars = "\t\n\r\b\f\\\"";
	
	private int parameterIndex = 0;
	private Map<String,Table> tableAliasMap = new HashMap<String,Table>();
	private Stack<Table> tableStack = new Stack<Table>();
	private Statment statment;
	private Schema defaultSchema;
	private Map<String,Function> functionMap;
	private static TimeConverter timeConverter = new TimeConverter();
	public void setFunctionMap(Map<String,Function> map){
		this.functionMap = map;
	}

	public void setDefaultSchema(Schema schema){
		defaultSchema = schema;
	}
	
	
    /**
     * main method to test parser
     */
    public static void main( String args[] )
        throws com.meidusa.amoeba.parser.ParseException
        {

        MysqlParser p = null ;
        if ( args.length < 1  ) {
            System.out.println("Reading from stdin") ;
            p = new MysqlParser(System.in) ;
        }
        else {
            try {
                p = new MysqlParser(new DataInputStream(
                                new FileInputStream(args[0]))) ;
            }
            catch (FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new MysqlParser(System.in) ;
            }
        } // else ends here

        if ( args.length > 0 ) {
            System.out.println(args[0]) ;
        }
        Statment statment = p.doParse();
        System.out.println(statment.getExpression());
        System.out.println("paramCount=" + statment.getParameterCount());

    } // main ends here

   void jjtreeOpenNodeScope(Node n){
      //((SimpleNode)n).setFirstToken(getToken(1));
    }

   void jjtreeCloseNodeScope(Node n){
       // ((SimpleNode)n).setLastToken(token);
    }
    
	Function getFunction(String indent){
		if(functionMap == null){
			return null;	
		}else{
			return functionMap.get(indent);	
		}
		//return funMap.get(indent);
	}
	
	
	
	public Statment doParse() throws com.meidusa.amoeba.parser.ParseException{
		try{
			Statment statment = this.parse();
			if(statment != null){
				statment.setParameterCount(parameterIndex);
			}
			return statment;
		}catch(Exception e){
			throw new com.meidusa.amoeba.parser.ParseException(e);
		}
	}
	public Statment getParsedStatment(){
		return statment;
	}
	
	private Expression reverseExpression(boolean not,Expression expression){
		if(not){
			if(expression != null){
				return expression.reverse();
			}else{
				return null;
			}
		}else{
			return expression;
		}
	}
	
	private static String replaceEscape(String inputStr) {
		int len = inputStr.length();
		int p = 0;
		int i;
		
		StringBuilder output = new StringBuilder();
		
		while ((i = inputStr.indexOf('\\', p)) != -1) {
			output.append(inputStr.substring(p, i));
			
			if (i+1 == len) break;
			
			// find metacharacter
			char metac = inputStr.charAt(i+1);

			// find the index of the metac
			int k = metachars.indexOf(metac);
			if (k == -1) {
				// didn't find the metachar, leave sequence as found.
				// This code should be unreachable if the parser
				// is functioning properly because strings containing
				// unknown escape characters should not be accepted.
				output.append('\\');
				output.append(metac);
			} else {
				// its corresponding true char
				output.append(chars.charAt(k));   
			}

			// skip over both escape character & metacharacter
			p = i + 2;
		}

		// add the end of the input string to the output
		if (p < len)
			output.append(inputStr.substring(p));
		return output.toString();
	}
} // class MysqlParser ends here

PARSER_END(MysqlParser)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

/* Prefix      Meaning
    -------------------
    K_          Keyword
    O_          Operator
    S_          Substitutes
*/

TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */
{
	<K_DONET: "@">
|    <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_AS: "AS">
|   <K_BETWEEN:"BETWEEN">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BY:"BY">
|   <K_CASE:"CASE">
|   <K_CAST:"CAST">
|   <K_CHAR:"CHAR">
|   <K_CHARACTER:"CHARACTER">
|   <K_IGNORE:"IGNORE">
|   <K_DECIMAL:"DECIMAL">
|   <K_DEC:"DEC">
|   <K_DELETE:"DELETE">
|   <K_DISTINCT:"DISTINCT">
|   <K_DO:"DO">
|   <K_DUPLICATE:"DUPLICATE">
|   <K_DOUBLE:"DOUBLE">
|   <K_DROP:"DROP">
|   <K_ELSE:"ELSE">
|   <K_ELSEIF:"ELSEIF">
|   <K_END:"END">
|   <K_ESCAPE:"ESCAPE">
|   <K_EXISTS:"EXISTS">
|   <K_FETCH:"FETCH">
|   <K_FLOAT:"FLOAT">
|   <K_FOR:"FOR">
|   <K_FROM:"FROM">
|   <K_FULL:"FULL">
|   <K_GROUP:"GROUP">
|   <K_HAVING:"HAVING">
|   <K_IF:"IF">
|   <K_IN:"IN">
|   <K_IS:"IS">
|   <K_INTO:"INTO">
|   <K_INDEX:"INDEX">
|   <K_INNER:"INNER">
|   <K_INSERT:"INSERT">
|	<K_REPLACE:"REPLACE">
|   <K_INTEGER:"INTEGER">
|   <K_INT:"INT">
|   <K_JOIN:"JOIN">
|   <K_LEFT:"LEFT">
|   <K_LIKE:"LIKE">
|   <K_LOCK:"LOCK">
|   <K_LOOP:"LOOP">
|   <K_KEY:"KEY">
|   <K_CREATE:"CREATE">
|   <K_NOT:"NOT">
|   <K_NULL:"NULL">
|   <K_NULLS:"NULLS">
|   <K_NUMBER:"NUMBER">
|   <K_NUMERIC:"NUMERIC">
|   <K_OF:"OF">
|   <K_ON:"ON">
|	<K_NOWAIT:"NOWAIT">
|   <K_ONLY:"ONLY">
|   <K_OR:"OR">
|   <K_ORDER:"ORDER">
|   <K_OUTER:"OUTER">
|   <K_QUERYNO:"QUERYNO">
|   <K_OPTIMIZE:"OPTIMIZE">
|   <K_READ:"READ">
|   <K_REAL:"REAL">
|	<K_OPTION:"OPTION">

|  <K_EXPLAIN:"EXPLAIN">
|   <K_SELECT:"SELECT">
|   <K_SET:"SET">
|   <K_SOME:"SOME">
|   <K_TABLE:"TABLE">
|	<K_SHOW:"SHOW">
|   <K_MOD:"MOD">
|	<K_DIV:"DIV">
|   <K_THEN:"THEN">
|   <K_TO:"TO">
|   <K_UNION:"UNION">
|   <K_UNIQUE:"UNIQUE">
|   <K_UPDATE:"UPDATE">
|   <K_USE:"USE">
|   <K_USING:"USING">
|   <K_VALUES:"VALUES">
|   <K_VARCHAR2:"VARCHAR2">
|   <K_VARCHAR:"VARCHAR">
|   <K_WHEN:"WHEN">
|   <K_WHERE:"WHERE">
|   <K_WHILE:"WHILE">
|   <K_WITH:"WITH">
|	<K_TRUE: "TRUE">
|	<K_FALSE: "FALSE">
|	<K_LIMIT: "LIMIT">
|   <K_RIGHT:"RIGHT">
|   <K_INTERVAL:"INTERVAL">
|   <K_YEAR:"YEAR">
|   <K_MICROSECOND:"MICROSECOND">
|   <K_SECOND:"SECOND">
|   <K_DAY:"DAY">
|   <K_MINUTE:"MINUTE">
|   <K_MONTH:"MONTH">
|   <K_HOUR:"HOUR">
|	<K_COMMIT:"COMMIT">
|	<K_ROLLBACK:"ROLLBACK">

| < K_IGNORE_INDEX:"IGNORE INDEX" >
| < K_FORCE_INDEX:"FORCE INDEX" >
|	<K_TRANSACTION_ISOLATION_LEVEL:"TRANSACTION ISOLATION LEVEL">
//|	<K_TRANSACTION:"TRANSACTION">
//|	<K_BEGIN:"BEGIN">
|	<K_START_TRANSACTION:"START TRANSACTION">
//|	<K_SESSION:"SESSION">

|	<K_TRANSACTION_READ_COMMITTED:"READ COMMITTED">
|	<K_TRANSACTION_READ_UNCOMMITTED:"READ UNCOMMITTED">
|	<K_TRANSACTION_REPEATABLE_READ:"REPEATABLE READ">
|	<K_TRANSACTION_SERIALIZABLE:"SERIALIZABLE">
|	<K_CLIENT_CHARSET:"CLIENT CHARSET">
/*
|   <K_MICROSECOND:"MICROSECOND">
|   <K_MILLISECOND:"MILLISECOND">
|   <K_SECOND:"SECOND">
|   <K_DAY:"DAY">
|   <K_MINUTE:"MINUTE">
|   <K_MONTH:"MONTH">
|   <K_HOUR:"HOUR">

|   <K_TIME:"TIME">
|   <K_TIMESTAMP:"TIMESTAMP">
|   <K_DATE:"DATE">
|   <K_CONCAT:"CONCAT">
|   <K_NOW:"NOW">
|   <K_CURRENTDATE:"CURRENT_DATE">
|   <K_CURRENTTIME:"CURRENT_TIME">
|   <K_CURRENTTIMESTAMP:"CURRENT_TIMESTAMP">

|	<K_ISOLATION:"ISOLATION">

|	<K_LEVEL:"LEVEL">
|	<K_CHAIN:"CHAIN">
|	<K_RELEASE:"RELEASE">
|	<K_SNAPSHOT:"SNAPSHOT">
|	<K_WORK:"WORK">
|	<K_NO:"NO">
*/
}

TOKEN : /* Numeric Constants */
{
	< INTEGER_LITERAL: ( <DIGIT> )+ >
	|
	< FLOATING_POINT_LITERAL:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
|
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
	<#DIGIT: [
				"0" - "9",
				"\u0660" - "\u0669",
				"\u06f0" - "\u06f9",
				"\u0966" - "\u096f",
				"\u09e6" - "\u09ef",
				"\u0a66" - "\u0a6f",
				"\u0ae6" - "\u0aef",
				"\u0b66" - "\u0b6f",
				"\u0be7" - "\u0bef",
				"\u0c66" - "\u0c6f",
				"\u0ce6" - "\u0cef",
				"\u0d66" - "\u0d6f",
				"\u0e50" - "\u0e59",
				"\u0ed0" - "\u0ed9",
				"\u0f20" - "\u0f29",
				"\uff10" - "\uff19"
			]>
}

SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN:
{

< IDENTIFIER: ((["@"])*( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)*) >
| 	<#LETTER: [
				"a"-"z",
				"A"-"Z",
				"\u00aa",
				"\u00b5",
				"\u00ba",
				"\u00c0" - "\u00d6",
				"\u00d8" - "\u00f6",
				"\u00f8" - "\u01f5",
				"\u01fa" - "\u0217",
				"\u0250" - "\u02a8",
				"\u02b0" - "\u02b8",
				"\u02bb" - "\u02c1",
				"\u02d0" - "\u02d1",
				"\u02e0" - "\u02e4",
				"\u037a",
				"\u0386",
				"\u0388" - "\u038a",
				"\u038c",
				"\u038e" - "\u03a1",
				"\u03a3" - "\u03ce",
				"\u03d0" - "\u03d6",
				"\u03da",
				"\u03dc",
				"\u03de",
				"\u03e0",
				"\u03e2" - "\u03f3",
				"\u0401" - "\u040c",
				"\u040e" - "\u044f",
				"\u0451" - "\u045c",
				"\u045e" - "\u0481",
				"\u0490" - "\u04c4",
				"\u04c7" - "\u04c8",
				"\u04cb" - "\u04cc",
				"\u04d0" - "\u04eb",
				"\u04ee" - "\u04f5",
				"\u04f8" - "\u04f9",
				"\u0531" - "\u0556",
				"\u0559",
				"\u0561" - "\u0587",
				"\u05d0" - "\u05ea",
				"\u05f0" - "\u05f2",
				"\u0621" - "\u063a",
				"\u0640" - "\u064a",
				"\u0671" - "\u06b7",
				"\u06ba" - "\u06be",
				"\u06c0" - "\u06ce",
				"\u06d0" - "\u06d3",
				"\u06d5",
				"\u06e5" - "\u06e6",
				"\u0905" - "\u0939",
				"\u093d",
				"\u0958" - "\u0961",
				"\u0985" - "\u098c",
				"\u098f" - "\u0990",
				"\u0993" - "\u09a8",
				"\u09aa" - "\u09b0",
				"\u09b2",
				"\u09b6" - "\u09b9",
				"\u09dc" - "\u09dd",
				"\u09df" - "\u09e1",
				"\u09f0" - "\u09f1",
				"\u0a05" - "\u0a0a",
				"\u0a0f" - "\u0a10",
				"\u0a13" - "\u0a28",
				"\u0a2a" - "\u0a30",
				"\u0a32" - "\u0a33",
				"\u0a35" - "\u0a36",
				"\u0a38" - "\u0a39",
				"\u0a59" - "\u0a5c",
				"\u0a5e",
				"\u0a72" - "\u0a74",
				"\u0a85" - "\u0a8b",
				"\u0a8d",
				"\u0a8f" - "\u0a91",
				"\u0a93" - "\u0aa8",
				"\u0aaa" - "\u0ab0",
				"\u0ab2" - "\u0ab3",
				"\u0ab5" - "\u0ab9",
				"\u0abd",
				"\u0ae0",
				"\u0b05" - "\u0b0c",
				"\u0b0f" - "\u0b10",
				"\u0b13" - "\u0b28",
				"\u0b2a" - "\u0b30",
				"\u0b32" - "\u0b33",
				"\u0b36" - "\u0b39",
				"\u0b3d",
				"\u0b5c" - "\u0b5d",
				"\u0b5f" - "\u0b61",
				"\u0b85" - "\u0b8a",
				"\u0b8e" - "\u0b90",
				"\u0b92" - "\u0b95",
				"\u0b99" - "\u0b9a",
				"\u0b9c",
				"\u0b9e" - "\u0b9f",
				"\u0ba3" - "\u0ba4",
				"\u0ba8" - "\u0baa",
				"\u0bae" - "\u0bb5",
				"\u0bb7" - "\u0bb9",
				"\u0c05" - "\u0c0c",
				"\u0c0e" - "\u0c10",
				"\u0c12" - "\u0c28",
				"\u0c2a" - "\u0c33",
				"\u0c35" - "\u0c39",
				"\u0c60" - "\u0c61",
				"\u0c85" - "\u0c8c",
				"\u0c8e" - "\u0c90",
				"\u0c92" - "\u0ca8",
				"\u0caa" - "\u0cb3",
				"\u0cb5" - "\u0cb9",
				"\u0cde",
				"\u0ce0" - "\u0ce1",
				"\u0d05" - "\u0d0c",
				"\u0d0e" - "\u0d10",
				"\u0d12" - "\u0d28",
				"\u0d2a" - "\u0d39",
				"\u0d60" - "\u0d61",
				"\u0e01" - "\u0e2e",
				"\u0e30",
				"\u0e32" - "\u0e33",
				"\u0e40" - "\u0e46",
				"\u0e81" - "\u0e82",
				"\u0e84",
				"\u0e87" - "\u0e88",
				"\u0e8a",
				"\u0e8d",
				"\u0e94" - "\u0e97",
				"\u0e99" - "\u0e9f",
				"\u0ea1" - "\u0ea3",
				"\u0ea5",
				"\u0ea7",
				"\u0eaa" - "\u0eab",
				"\u0ead" - "\u0eae",
				"\u0eb0",
				"\u0eb2" - "\u0eb3",
				"\u0ebd",
				"\u0ec0" - "\u0ec4",
				"\u0ec6",
				"\u0edc" - "\u0edd",
				"\u0f40" - "\u0f47",
				"\u0f49" - "\u0f69",
				"\u10a0" - "\u10c5",
				"\u10d0" - "\u10f6",
				"\u1100" - "\u1159",
				"\u115f" - "\u11a2",
				"\u11a8" - "\u11f9",
				"\u1e00" - "\u1e9b",
				"\u1ea0" - "\u1ef9",
				"\u1f00" - "\u1f15",
				"\u1f18" - "\u1f1d",
				"\u1f20" - "\u1f45",
				"\u1f48" - "\u1f4d",
				"\u1f50" - "\u1f57",
				"\u1f59",
				"\u1f5b",
				"\u1f5d",
				"\u1f5f" - "\u1f7d",
				"\u1f80" - "\u1fb4",
				"\u1fb6" - "\u1fbc",
				"\u1fbe",
				"\u1fc2" - "\u1fc4",
				"\u1fc6" - "\u1fcc",
				"\u1fd0" - "\u1fd3",
				"\u1fd6" - "\u1fdb",
				"\u1fe0" - "\u1fec",
				"\u1ff2" - "\u1ff4",
				"\u1ff6" - "\u1ffc",
				"\u207f",
				"\u2102",
				"\u2107",
				"\u210a" - "\u2113",
				"\u2115",
				"\u2118" - "\u211d",
				"\u2124",
				"\u2126",
				"\u2128",
				"\u212a" - "\u2131",
				"\u2133" - "\u2138",
				"\u3005",
				"\u3031" - "\u3035",
				"\u3041" - "\u3094",
				"\u309b" - "\u309e",
				"\u30a1" - "\u30fa",
				"\u30fc" - "\u30fe",
				"\u3105" - "\u312c",
				"\u3131" - "\u318e",
				"\u4e00" - "\u9fa5",
				"\uac00" - "\ud7a3",
				"\uf900" - "\ufa2d",
				"\ufb00" - "\ufb06",
				"\ufb13" - "\ufb17",
				"\ufb1f" - "\ufb28",
				"\ufb2a" - "\ufb36",
				"\ufb38" - "\ufb3c",
				"\ufb3e",
				"\ufb40" - "\ufb41",
				"\ufb43" - "\ufb44",
				"\ufb46" - "\ufbb1",
				"\ufbd3" - "\ufd3d",
				"\ufd50" - "\ufd8f",
				"\ufd92" - "\ufdc7",
				"\ufdf0" - "\ufdfb",
				"\ufe70" - "\ufe72",
				"\ufe74",
				"\ufe76" - "\ufefc",
				"\uff21" - "\uff3a",
				"\uff41" - "\uff5a",
				"\uff66" - "\uffbe",
				"\uffc2" - "\uffc7",
				"\uffca" - "\uffcf",
				"\uffd2" - "\uffd7",
				"\uffda" - "\uffdc"
			]>
|   < #SPECIAL_CHARS: "$" | "_">
|   < STRING_LITERAL: "'" ((~["'"])|("\\" "'"))* "'">
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
|	< S_COMMA_IDENTIFIER: "`" ((["@"])*( <LETTER> )+ ( <DIGIT> | "-"|<LETTER> |<SPECIAL_CHARS>)*) "`">
|   < S_PARAMETER_MARKER: "?">

}


Statment parse()      :
{
	Expression expression = null;
	Statment statment = null;
}
{
    ["EXPLAIN"] (
    statment = DeleteQuery()
    |
    statment = InsertQuery()
    |
    statment= SelectQuery()
    |
    statment = UpdateQuery()
    |
    "SET" statment = PropertySetQuery(new PropertyStatment())
    |
    statment = SelectSchema()
    |(<K_COMMIT> /*[<K_WORK>] [<K_AND> [<K_NO>] <K_CHAIN>] [[<K_NO>] <K_RELEASE>]*/){statment = new CommitStatment();}
    |(<K_ROLLBACK>/*[<K_WORK>] [<K_AND> [<K_NO>] <K_CHAIN>] [[<K_NO>] <K_RELEASE>]*/){statment = new RollbackStatment();}
    |(<K_START_TRANSACTION>){statment = new StartTansactionStatment();}
    )[    ("FORCE INDEX" |"IGNORE INDEX") "(" <IDENTIFIER>      ( "," <IDENTIFIER>)* ")"] (";"|<EOF>)
    {
    	if(statment instanceof DMLStatment){
	    	List<Table> list = new ArrayList<Table>();
			for(Map.Entry<String,Table> entry : tableAliasMap.entrySet()){
				if(!list.contains(entry.getValue())){
					list.add(entry.getValue());
				}
			}
			
			Table[] tables = new Table[list.size()];
			list.toArray(tables);
			((DMLStatment)statment).setTables(tables);
    	}
        return statment;
    }
}
Statment SelectSchema() :{
	Token t = null;
	String schema = null;
}{
	<K_USE> (token=<STRING_LITERAL>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<S_QUOTED_IDENTIFIER>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<S_COMMA_IDENTIFIER>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<IDENTIFIER>{schema = t.image;}){
		PropertyStatment statment = new PropertyStatment();
		statment.addProperty("schema",new ConstantExpression(schema));
		return statment;
	}
}

/*
Statment ShowQuery() :{
	Expression expression = null;
	Column column = null;
	Table table = null;
}{
	"SHOW"{return ShowStatment.STATMENT;}//[(<K_CREATE> [<K_TABLE>|<IDENTIFIER>])|<K_FULL>] column = ColumnName() [<K_FROM> table = TableReference()]{
		ColumnExpression columnExpression = new ColumnExpression();
		columnExpression.setColumn(column);
		ShowStatment show = new ShowStatment();
		show.setExpression(columnExpression);
		return show;
	}
}
	
*/
Statment PropertySetQuery(PropertyStatment statment) :{
	Expression expression = null;
	
	Token name = null;
	Token valueToken = null;
	Comparable value = null;
	String propertyName = null;
}{
	(["SESSION" | <K_OPTION>] ((<K_TRANSACTION_ISOLATION_LEVEL>(
				<K_TRANSACTION_READ_COMMITTED>{value=Connection.TRANSACTION_READ_COMMITTED;}
				|<K_TRANSACTION_READ_UNCOMMITTED>{value=Connection.TRANSACTION_READ_UNCOMMITTED;}
				|<K_TRANSACTION_SERIALIZABLE>{value=Connection.TRANSACTION_SERIALIZABLE;}
				|<K_TRANSACTION_REPEATABLE_READ>{value=Connection.TRANSACTION_REPEATABLE_READ;}
				)){propertyName = "TRANSACTIONISOLATION";}
			|
			(<K_CLIENT_CHARSET>{propertyName = "charset";} 
				(valueToken = <IDENTIFIER> {value = valueToken.image;}
				| valueToken = <STRING_LITERAL>{value = (valueToken.image).substring(1,valueToken.image.length()-1);}
				|valueToken = <S_QUOTED_IDENTIFIER>{value = valueToken.image;}
				))
			|
			(name = <IDENTIFIER>{propertyName = name.image;}["." name=<IDENTIFIER>{propertyName = propertyName+"."+name.image;}] ["="] (
			valueToken= <K_NULL>{ value = "null";}
			| valueToken= <K_TRUE> {value = Boolean.TRUE;}
			| valueToken= <K_FALSE> {value = Boolean.FALSE;}
			| valueToken = <IDENTIFIER> {value = valueToken.image;}
			| valueToken = <INTEGER_LITERAL>{value = Long.valueOf(valueToken.image);} 
			| valueToken = <STRING_LITERAL>{value = (valueToken.image).substring(1,valueToken.image.length()-1);} //{value = valueToken.image.substring(1,token.image.length()-1);}
			| valueToken = <S_QUOTED_IDENTIFIER>{value = valueToken.image;}
			))
			))["," PropertySetQuery(statment)]{
		if(value != null){
			ConstantExpression consExp= new ConstantExpression(value);
			statment.addProperty(propertyName,consExp);
		}
		return statment;
	}
}

Statment UpdateQuery():
{
	Expression expression = null;
	Table table = null;
	DMLStatment statment = null;
}
{
   	(table = UpdateStatement()
    [expression= WhereClause() ]){
    	statment = new UpdateStatment();
    	statment.setExpression(expression);
    	return statment;	
    }
}

Table UpdateStatement():
{
	Table table = null;
}
{
    ("UPDATE"
    table = TableReference()["," TableReference()]
    "SET" AssignmentClause()){
    	return table;
    }
}

Expression AssignmentClause():
{
	Expression expression = null;
}
{
       (expression= ColumnValues(){
       
       
       }
        |  (   "(" UpdateColumn() ("," UpdateColumn())* ")" "=" "(" ( LOOKAHEAD(2) UpdateValues() |  FullSelectStatement() ) ")" )
        ){
        	return expression;
        }
}

void UpdateColumn():
{}
{
    ColumnName()
}

List<Expression> UpdateValues():
{
	Expression expression = null;
	List<Expression> list = new ArrayList<Expression>();
}
{
       expression= UpdateValue(){list.add(expression);} ("," expression=UpdateValue(){list.add(expression);})*{
       	
       	return list;
       }
}

Expression UpdateValue():
{
Expression expression = null;
}
{
    expression =  SQLSimpleExpression(){
       return 	expression;
    }
}

Statment DeleteQuery():
{
	Expression expression = null;
	Table table = null;
	DMLStatment statment = null;
}
{
    (table = DeleteStatement()
    [expression = WhereClause()]){
    	statment = new DeleteStatment();
    	statment.setExpression(expression);
    	return 	statment;
    }
}

Table DeleteStatement():
{
	Table table = null;
}
{
    "DELETE" ["FROM"] table = TableReference(){
    	return table;	
    }
}


Statment InsertQuery():
{
	Table table = null;
	DMLStatment statment = new InsertStatment();
	Expression expression = null;
	List<Column> insertColumns = null;
	List<Expression> insertValues = null;
}
{
    (<K_INSERT>|<K_REPLACE>) [<K_IGNORE>] [<K_INTO>] table = TableName() ([LOOKAHEAD(4) "(" insertColumns = InsertColumns() ")"]
    ( insertValues = InsertValues() | expression = FullSelectStatement())
    ([<K_ON> <K_DUPLICATE> <K_KEY> <K_UPDATE> ColumnValues()])
    {
    	if(insertValues == null){
    		statment.setExpression(expression);
    	}else{
    		if(insertColumns != null){
	    		AndExpression andExpression = new AndExpression();
	    		int index = 0;
	    		for(Column column:insertColumns){
	    			ColumnExpression colExpression = new ColumnExpression();
	    			colExpression.setColumn(column);
	    			ComparisonExpression compExp = new ComparisonExpression();
	    			compExp.setComparison(Comparative.Equivalent);
	    			compExp.setExpression(insertValues.get(index));
	    			colExpression.setExpression(compExp);
	    			andExpression.addExpression(colExpression);
	    			index ++;
	    		}
	    		statment.setExpression(andExpression);
    		}
    	}
    	
    } | "SET" expression = AssignmentClause(){statment.setExpression(expression);}){
    	return statment;
    }
}


List<Column> InsertColumns()      :
{
	List<Column> insertColumns = new ArrayList<Column>();
	Column column = null;
}
{
        (column = InsertColumn(){insertColumns.add(column);} ("," column = InsertColumn(){insertColumns.add(column);})*){
        	return insertColumns;
        }
}

//This is just a wrapper to provide different formatting in case of Insert
Column InsertColumn():
{
	Column column = null;
}
{
   column = ColumnName(){
   		return column;
   }
}

List<Expression> InsertValues():
{
	List<Expression> insertValues = new ArrayList<Expression>();
	Expression expression = null;
}
{
       ("VALUES" "("  expression = InsertValue(){insertValues.add(expression);} ("," expression = InsertValue(){insertValues.add(expression);})*  ")"){
       	return insertValues;
       }
}

//This is just a wrapper to provide different formatting in case of Insert
Expression InsertValue():
{
	Expression expression = null;
}
{
 	expression = SQLSimpleExpression(){
 		return expression;	
 	}
}


Statment SelectQuery():
{
	Expression expression = null;
	DMLStatment statment = null;
}
{
   (expression = FullSelectStatement()
    (ExtraClauses())*)
    {
    	statment = new SelectStatment();
    	statment.setExpression(expression);
    	return statment;
    }
    
}


Expression ColumnValues()      :
{
	Expression expression = null;
	AndExpression andExpression = new AndExpression();
}
{
 (expression= ColumnValue(){if(expression != null) andExpression.addExpression(expression);} ("," expression = ColumnValue(){if(expression != null) andExpression.addExpression(expression);})*){
  return andExpression;
 }
}

Expression ColumnValue()       :
{
ColumnExpression colExpression = new ColumnExpression();
Expression expression = null;
Column column = null;
}
{
       (column= ColumnName() "=" expression = UpdatedValue()){
       	if(expression == null) return null;
       	
       	colExpression.setColumn(column);
       	ComparisonExpression compExp = new ComparisonExpression();
		compExp.setComparison(Comparative.Equivalent);
		compExp.setExpression(expression);
		colExpression.setExpression(compExp);
       	return colExpression;
       }
}


Expression UpdatedValue()      : // Can be a subquery or a expression
{
Expression expression = null;
}
{
  (LOOKAHEAD(("(")+ "SELECT")
  "(" expression = SubSelectStatement() ")"
  |
  expression= SQLSimpleExpression()){
  	return expression;
  }
}


ComparisonExpression IsNullClause()      :
{
	int comparison = Comparative.Equivalent;
}
{
    (<K_IS> [<K_NOT>{comparison = Comparative.NotEquivalent;}] <K_NULL>)
    {
    	ComparisonExpression comparativeExpression = new ComparisonExpression();
		comparativeExpression.setComparison(comparison);
		comparativeExpression.setExpression(new ConstantExpression(null));	
		return comparativeExpression;
    }
}



/*
*	Tabel Column
*/
Column ColumnName()      :
{
	String schemaName = null;
	String tableName = null;
	String columnName = null;
	Column column =  new Column();
	Table table = null;
}
{
    // schema.table.column
   schemaName = EntityName() [ "." tableName = EntityName() ["." columnName = EntityName()]]{
	   	if(tableName == null){
	   		columnName = schemaName;
	   		schemaName = null;
	   		if(tableStack.size()>0){
	   			table = tableStack.peek();
	   		}
	   	}else{
	   		if(columnName == null){
	   			columnName = tableName;
	   			tableName = schemaName;
	   			schemaName = null;
	   			table = tableAliasMap.get(tableName);
	   		}
	   	}
	   	column.setTable(table);
	   	column.setName(columnName);
	   	return column;
   }
}

String EntityName()      :
{
	Token token = null;
}
{
    token = "MOD" {return token.image;}
    |
    token = "MONTH" {return token.image;}
    |
    token = "YEAR" {return token.image;}
    |
    token = "DAY" {return token.image;}
    |
    token = "HOUR" {return token.image;}
    |
    token = "MINUTE" {return token.image;}
    |
    token = "SECOND" {return token.image;}
    |
    token = "MICROSECOND" {return token.image;}
    |
 	token =  <IDENTIFIER>{
 		return token.image;
 	}
 	|
 	token =  <S_QUOTED_IDENTIFIER>{
 		return token.image.substring(1,token.image.length()-1);
 	}
 	| token = <S_COMMA_IDENTIFIER>{
 		return token.image.substring(1,token.image.length()-1);	
 	}
}

String Relop():
{
	Token token;
}
{
  (token = "=" | token = "!=" | token = "<>" | token = ">" | token = ">=" |token = "<" |token= "<="){
  	return token.image;
  }
  
}

Table TableName() :
{
	String schemaName = null;
	String tableName = null;
	Table table = null;
	Schema schema = null;
	
}
{
     schemaName = EntityName() 
     ["." 
     	tableName= EntityName()
     ]{
     	if(tableName == null){
     		tableName = schemaName;
     		schemaName = null;	
     	}
     	table = new Table();
     	table.setName(tableName);
     	if(schemaName != null){
     		schema = new Schema();
     		schema.setName(schemaName);
     		table.setSchema(schema);	
     	}else{
     		table.setSchema(defaultSchema);	
     	}
     	tableAliasMap.put(table.getName(),table);
     	tableStack.push(table);
     	return table;
     }
}

Table TableReference():
{
	Table table = null;
	Token token = null;
}
{
    table = TableName() 
     [["AS"] token = <IDENTIFIER>{
    	table.setAlias(token.image);
    }]{
   	 if(table.getAlias() != null){
   	 	tableAliasMap.put(table.getAlias(),table);	
   	 }
   	 return table;
   	 }
}

void CaseStatement() :
{}
{
    "CASE" [SQLSimpleExpression()] WhenStatement() (WhenStatement())* [ElseStatement()] "END"
}


void WhenStatement() :
{}
{
	"WHEN" SQLExpression() "THEN" SQLSimpleExpression()
}

void ElseStatement() :
{}
{
	"ELSE" SQLSimpleExpression()
}


void ExtraClauses()       :
{}
{
    (
    	LOOKAHEAD(2) ForUpdateClause()
    	| LOOKAHEAD(2) ReadOnlyClause()
    	| OptimizeForClause()
    	| WithClause()
    	| QuerynoClause()
    	| FetchFirstClause()
    )
}

Expression FullSelectStatement():
{
	Expression expression = null;
	Expression unionedExpression = null;
}
{
	((expression = SubSelectStatement() [ UnionClause() unionedExpression = FullSelectStatement()])
	| "(" expression = FullSelectStatement() ")"){
		if(unionedExpression != null){
			if(expression == null){
				return unionedExpression;
			}else{
				expression = new OrExpression(expression);
				((OrExpression)expression).addExpression(unionedExpression);
				return expression;
			}
		}else{
			return expression;
		}
	}
}

void UnionClause():
{}
{
        "UNION" ["ALL"]
}

Expression SubSelectStatement():
{
	Expression expression = null;
}
{
    (SelectClause()
    [FromClause()]
    [ expression = WhereClause()]
    [ GroupByClause() ]
    [ OrderByClause() ]
    [<K_LIMIT> ((<S_PARAMETER_MARKER> {parameterIndex++;})| <INTEGER_LITERAL>)["," ((<S_PARAMETER_MARKER> {parameterIndex++;}) | <INTEGER_LITERAL>)]])
    {
    	return expression;	
    }
}

void SelectClause():
{}
{
	 "SELECT" [ "ALL" | "DISTINCT"|"DISTINCTROW" ]["HIGH_PRIORITY"]["STRAIGHT_JOIN"] ["SQL_SMALL_RESULT"] ["SQL_BIG_RESULT"] ["SQL_BUFFER_RESULT"] ["SQL_CACHE" | "SQL_NO_CACHE"] ["SQL_CALC_FOUND_ROWS"] SelectList()
}

/* Checks for whatever follows  SELECT */
void SelectList() :
{}
{
    ("*"("," SelectItem())*) | (SelectItem() ("," SelectItem())*)
}

void SelectItem():
{}
{
    (
        LOOKAHEAD(2) EntityName()".*"  /* table.* */
        |   LOOKAHEAD(4) EntityName()"." EntityName() ".*" /* schema.table.* */
        |   SQLSimpleExpression()    // Column or Expression
    )[("=" SQLSimpleExpression())] [["AS"] <IDENTIFIER>] // Column Alias
}


void FromClause() :
{}
{
    "FROM" FromItem() ( "," FromItem())*
}


void FromItem() :
{}
{
  TableSpec() (JoinedTable())* [<K_FORCE_INDEX> "(" ColumnName() ")"]
}


void JoinedTable() :
{}
{
	((["NATURAL"] (("LEFT"|"RIGHT") ["OUTER"])) | (["INNER" | "CROSS"])) "JOIN"
	(LOOKAHEAD(2) TableSpec() (JoinedTable())* | "(" TableSpec() (JoinedTable())* ")") JoinCondition()
}

void TableSpec():
{
	Table table = null;
}
{
	table = TableReference()
	| (["TABLE"] "(" FullSelectStatement() ")" [CorrelationClause()])

}

void JoinCondition():
{}
{
     ("ON" SQLExpression())|("USING" "(" SQLExpression() ")")
}

Expression WhereClause():
{
	Expression expression;
}
{
    "WHERE" expression = SQLExpression(){
    	return expression;
    }
}


void CorrelationClause()       :
{}
{
	["AS"] <IDENTIFIER> [ColumnNames()]
}

void ColumnNames() :
{}
{
	"(" (<IDENTIFIER>|<S_COMMA_IDENTIFIER>) ("," (<IDENTIFIER>|<S_COMMA_IDENTIFIER>))* ")"
}

void GroupByClause() :
{}
{
    "GROUP" "BY" GroupByColumn() ("," GroupByColumn())*
    ["HAVING" SQLExpression()]
}

void GroupByColumn():
{}
{
      SQLSimpleExpression()
}

void OrderByClause():
{}
{
    "ORDER" "BY" ("rand(" ")" |( OrderByColumn() [(<IDENTIFIER>|<S_COMMA_IDENTIFIER>)]
        ("," OrderByColumn() [(<IDENTIFIER>|<S_COMMA_IDENTIFIER>)])*))
}


void OrderByColumn():
{}
{
      SQLSimpleExpression()
}


Expression SQLExpression() :
{
	OrExpression orExpression = null;
	AndExpression andExpression = null;
	Expression expression = null;
	Token token;
	int count = 0;
}
{
    expression = SQLAndExpression(){
    	orExpression = new OrExpression(expression);
    }
    ("OR"
		expression =  SQLAndExpression(){
			if(expression != null){
				count++;
				orExpression.addExpression(expression);
			}
		}
    )*{
    	if(count >0){
    		return orExpression;
    	}else{
    		return expression;
    	}
    }
}

Expression SQLAndExpression() :
{
	AndExpression andExpression = null;;
	Expression expression;
	Expression currentExpression;
}
{
    expression = SQLUnaryLogicalExpression()
    ( "AND" 
    	currentExpression = SQLUnaryLogicalExpression(){
    	
    	if(andExpression == null && currentExpression != null){
    		andExpression = new AndExpression(expression);
    	}
    	if(currentExpression != null){
    		andExpression.addExpression(currentExpression);
    	}
    })*{
    	if(andExpression != null){
    		return andExpression;
    	}else{
    		return expression;
    	}
    	
    }
}

Expression SQLUnaryLogicalExpression() :
{
	Expression expression = null;
	boolean not = false;
}
{
    LOOKAHEAD(2) expression= ExistsClause() {
    return expression;
    }
|   (["NOT"{not = true;}]expression= SQLRelationalExpression()){
		return reverseExpression(not,expression);
}
}

Expression ExistsClause() :
{
	Expression expression = null;
	boolean not = false;
}
{
    ["NOT"{not = true;}] "EXISTS" "(" expression = FullSelectStatement() ")"{
    	return reverseExpression(not,expression);
    }
}

Expression SQLRelationalExpression()       :
{
	Expression expression = null;
	Expression otherExpression = null;
	String functionName = null;
	int function = 0;
}
{
    /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */

    (LOOKAHEAD("(" SQLSimpleExpression() ",")
     "(" SQLExpressionList() ")"
|
    (expression = SQLSimpleExpression()))
	
    /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */
   (    functionName = Relop(){
    		function =	Comparative.getComparisonByIdent(functionName);
    	}
    	otherExpression = SQLRelationalOperatorExpression()
   			{
   				if(expression == null ||  otherExpression == null){
   					return null;	
   				}
   				
		   		if(expression instanceof ColumnExpression && !(otherExpression instanceof ColumnExpression)){
		   			ColumnExpression colExp = (ColumnExpression)expression;
		   			ComparisonExpression comparativeExpression = new ComparisonExpression();
		   			comparativeExpression.setComparison(function);
		   			comparativeExpression.setExpression(otherExpression);
		   			colExp.setExpression(comparativeExpression);
		   			return colExp;
		   		}else if(!(expression instanceof ColumnExpression) && (otherExpression instanceof ColumnExpression)){
		   			ColumnExpression colExp = (ColumnExpression)otherExpression;
		   			ComparisonExpression comparativeExpression = new ComparisonExpression();
		   			comparativeExpression.setComparison(Comparative.exchangeComparison(function));
		   			comparativeExpression.setExpression(expression);
		   			colExp.setExpression(comparativeExpression);
		   			return colExp;
		   		}else{
		   			return null;
		   		}
   			}
        |  LOOKAHEAD(2) (otherExpression=SQLInClause(expression)
	        {
	        	return otherExpression;
	        })
        |  LOOKAHEAD(2) (otherExpression=SQLBetweenClause(expression){
        	return otherExpression;
        })
        |  LOOKAHEAD(2) (otherExpression = SQLLikeClause()){
        	if(expression instanceof ColumnExpression){
    			ColumnExpression colExp = (ColumnExpression)expression;
    			colExp.setExpression((ComparisonExpression)otherExpression);
    			return colExp;
    		}else{
    			return null;	
    		}
        }
        |  LOOKAHEAD(2)(otherExpression = IsNullClause(){
    		if(expression instanceof ColumnExpression){
    			ColumnExpression colExp = (ColumnExpression)expression;
    			colExp.setExpression((ComparisonExpression)otherExpression);
    			return colExp;
    		}else{
    			return null;	
    		}
        })
   )?{
   		return expression;
   }
}

List<Expression> SQLExpressionList()       :
{
	List<Expression> list = new ArrayList<Expression>();
	Expression expression;
}
{
   expression = SQLSimpleExpression(){
   	list.add(expression);
    	
    } ("," expression = SQLSimpleExpression(){
    		list.add(expression);
    })*{
    	return list;	
    }
}

Expression SQLRelationalOperatorExpression()        :
{
	
	Expression expression = null;
	String functionName;
	int function;
}
{

    /* Only after seeing an ANY/ALL or "(" followed by a FullSelectStatement() we can
    determine that is is a sub-query
    */
    (   LOOKAHEAD("ANY" | "ALL" | "(" "SELECT")
        (["ALL" | "ANY"] "(" FullSelectStatement() ")")
        |
        expression = SQLSimpleExpression()
    )
    {
    	return expression;
    }
}

Expression SQLInClause(Expression inputExpression)      :
{
	boolean not = false;
	Expression expression = null;
	List<Expression> list = null;
	
}
{
    ["NOT"{not = true;}] "IN" "(" (LOOKAHEAD(2) list=SQLExpressionList() | expression = FullSelectStatement()) ")" {
    	
    	if(list == null){
    		return expression;	
    	}
    	if(list.size()==1){
    		
    		Expression item = list.get(0);
    		ComparisonExpression comparativeExpression = new ComparisonExpression();
    		comparativeExpression.setExpression(item);
    		comparativeExpression.setComparison(not?Comparative.NotEquivalent:Comparative.Equivalent);
	    		
    		if(inputExpression instanceof ColumnExpression){
				((ColumnExpression)inputExpression).setExpression(comparativeExpression);
				return 	inputExpression;
    		}else{
    			return comparativeExpression;
    		}
    		
    	}else{
    		BaseExpressionList baseList = null;
    		if(not){
    			baseList = new AndExpression(null);
    		}else{
    			baseList = new OrExpression(null);
    		}
    		
	    	for(Expression item:list){
	    		
	    		ComparisonExpression comparativeExpression = new ComparisonExpression();
    			comparativeExpression.setExpression(item);
    			comparativeExpression.setComparison(not?Comparative.NotEquivalent:Comparative.Equivalent);
	    		if(inputExpression instanceof ColumnExpression){
	    			ColumnExpression columnExpression = new ColumnExpression();
	    			columnExpression.setExpression(comparativeExpression);
	    			columnExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
		    		baseList.addExpression(columnExpression);
	    		}else{
	    			baseList.addExpression(comparativeExpression);
	    		}
	    	}
	    	return baseList;
    	}
    }
}

Expression SQLBetweenClause(Expression inputExpression)      :
{
	boolean not = false;
	Expression minExpression = null;
	Expression maxExpression = null;
	
}
{
    ["NOT"{not = true;}] "BETWEEN" minExpression = SQLSimpleExpression() "AND" maxExpression = SQLSimpleExpression(){
    	ComparisonExpression comparativeMinExpression = new ComparisonExpression();
    	comparativeMinExpression.setExpression(minExpression);
    	comparativeMinExpression.setComparison(Comparative.GreaterThanOrEqual);
    	
    	ComparisonExpression comparativeMaxExpression = new ComparisonExpression();
    	comparativeMaxExpression.setExpression(maxExpression);
    	comparativeMaxExpression.setComparison(Comparative.LessThanOrEqual);
    	AndExpression andExpression = new AndExpression();
    	if(inputExpression instanceof ColumnExpression){
    		ColumnExpression columnMinExpression = new ColumnExpression();
			columnMinExpression.setExpression(comparativeMinExpression);
			columnMinExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
			
			ColumnExpression columnMaxExpression = new ColumnExpression();
			columnMaxExpression.setExpression(comparativeMaxExpression);
			columnMaxExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
			
			andExpression.addExpression(columnMinExpression);
			andExpression.addExpression(columnMaxExpression);
    	}else{
    		andExpression.addExpression(comparativeMinExpression);
    		andExpression.addExpression(comparativeMaxExpression);
    	}
    	
		return reverseExpression(not,andExpression);
    }
}

Expression SQLLikeClause()      :
{
	Expression expression = null;
	boolean not = false;
}
{
	["NOT"{not = true;}] "LIKE" expression = SQLSimpleExpression(){
		ComparisonExpression comparisonExpression = new ComparisonExpression();
		comparisonExpression.setExpression(expression);
		comparisonExpression.setComparison(not?Comparative.NotLike:Comparative.Like);
		return comparisonExpression;	
	}
}

Expression SQLSimpleExpression()      :
{
	Expression expression = null;
	Token token = null;
}
{
    (expression= SQLAddSubtractExpression()){
    	
    	return expression;	
    } 
}

Expression SQLAddSubtractExpression()      :
{
	Expression expression = null;
	Expression otherExpression = null;
	Token token = null;
	Function function;
	FunctionExpression superExpression = null;
}
{
       (expression = SQLMultiplicativeExpression() ((token = "+" | token = "-" | token = "||"  | token = "|"  | token = "&" ) otherExpression = SQLMultiplicativeExpression(){
		    function = getFunction(token.image.toUpperCase());
		    if(function == null) return null;
		    FunctionExpression functionExpression = new FunctionExpression();
		    functionExpression.setFunction(function);
       		if(superExpression == null){
       			functionExpression.addArgExpression(expression);
		    	functionExpression.addArgExpression(otherExpression);
       		}else{
       			functionExpression.addArgExpression(superExpression);
       			functionExpression.addArgExpression(otherExpression);
       		}
       		superExpression = functionExpression;
       })*){
       		if(superExpression == null){
       			return expression;
       		}else{
       			return superExpression;
       		}
       }
}



Expression SQLMultiplicativeExpression()      :
{
	FunctionExpression functionExpression;
	Expression expression;
	Expression otherExpression;
	Token token;
}
{
  expression = SQLUnaryExpression() ( (token = "*" | token = "/"  | token= "%" | token = "&" | token = "MOD" | token = "DIV" ) otherExpression = SQLUnaryExpression(){
  	Function function = getFunction(token.image.toUpperCase());
  	if(function != null && expression != null && otherExpression != null){
	  	functionExpression = new FunctionExpression();
	    functionExpression.setFunction(function);
	    functionExpression.addArgExpression(expression);
	    functionExpression.addArgExpression(otherExpression);
	    expression = functionExpression;
  	}
  	
  })*{
  	return expression;
  }
}


/**
void SQLExpotentExpression() #void:
{}
{
    SQLUnaryExpression() //( "**" SQLUnaryExpression())*
}
**/

Expression SQLUnaryExpression()      :
{
	Expression expression;
	boolean isSub = false;
}
{
    ["~" | "+" | "-"{isSub=true;}] expression = SQLPrimaryExpression(){
    	if(isSub){
    		Function function = getFunction("-");
    		if(function != null){
	    		FunctionExpression funExp = new FunctionExpression();
	    		ConstantExpression consExp = new ConstantExpression(0);
	    		funExp.addArgExpression(consExp);
	    		funExp.addArgExpression(expression);
	    		funExp.setFunction(function);
	    		return funExp;
    		}else{
    			return null;	
    		}
    	}
    	return expression;
    }
}


Expression SQLPrimaryExpression()      :
{
	Token t = null;
	Column column = null;
	Expression expression = null;
	Comparable value = null;
}
{(
t=<K_NULL>{
	return new ConstantExpression(null);
}
|t=<K_TRUE> {
		return new ConstantExpression(Boolean.TRUE);
	}
|	t=<K_FALSE> {
		return new ConstantExpression(Boolean.FALSE);
	}
|   t=<INTEGER_LITERAL>{
	
		try {
			value = Long.valueOf(t.image);
		} 
		catch (Exception e) {
		}
	return new ConstantExpression(value);
}
|   t=<FLOATING_POINT_LITERAL> {
	try {
		value = new BigDecimal(t.image);
	} 
	catch (Exception e) {
	}
	return new ConstantExpression(value);
}

|  t= <STRING_LITERAL>{
	// strip away double quotes at end of string
		String temp = (t.image).substring(1,t.image.length()-1);
		// replace escape characters
		temp = replaceEscape(temp);
		return new ConstantExpression(temp);
}
|  t= <S_PARAMETER_MARKER>{
	int index = parameterIndex++;
	return new ParameterExpression(index);
}
|   (<K_VALUES> "(" column =  ColumnName() ")" ){
	ColumnExpression column1Expression = new ColumnExpression();
	column1Expression.setColumn(column);
	return 	column1Expression;
}
| ("INTERVAL" expression=SQLExpression() (token = "YEAR" | token = "MONTH" | token = "DAY" | token = "HOUR" | token = "MINUTE" | token = "SECOND" | token = "MICROSECOND")){
		if(token != null){
    		int field = -1;
    		if(token.image.equalsIgnoreCase("YEAR")){
    			field = Calendar.YEAR;
    		}else if(token.image.equalsIgnoreCase("MONTH")){
    			field = Calendar.MONTH;
    		}else if(token.image.equalsIgnoreCase("DAY")){
    			field = Calendar.DATE;
    		}else if(token.image.equalsIgnoreCase("WEEK")){
    			field = Calendar.DATE;
    			FunctionExpression funExp = new FunctionExpression();
    			funExp.setFunction(this.getFunction("*"));
    			funExp.addArgExpression(expression);
    			funExp.addArgExpression(new ConstantExpression(7));
    			expression = funExp;
    		}else if(token.image.equalsIgnoreCase("HOUR")){
    			field = Calendar.HOUR;
    		}else if(token.image.equalsIgnoreCase("MINUTE")){
    			field = Calendar.MINUTE;
    		}else if(token.image.equalsIgnoreCase("SECOND")){
    			field = Calendar.SECOND;
    		}else if(token.image.equalsIgnoreCase("MICROSECOND")){
    			field = Calendar.MILLISECOND;
    			FunctionExpression funExp = new FunctionExpression();
    			funExp.setFunction(this.getFunction("/"));
    			funExp.addArgExpression(expression);
    			funExp.addArgExpression(new ConstantExpression(1000));
    			expression = funExp;
    		}
    		FunctionExpression funExp = new FunctionExpression();
    		funExp.setFunction(timeConverter);
    		funExp.addArgExpression(expression);
    		return funExp;
    	}
}
|   CastFunctionCall()
|   CaseStatement()
|   LOOKAHEAD({ getFunction(getToken(1).image.toUpperCase())!= null }) expression = OverloadedFunctionCall()
|   ("(" expression=SQLExpression() ")")
|   LOOKAHEAD(EntityName() [ "." EntityName() ["." EntityName()]] "(" ) FunctionCall()
|  ["~"] column =  ColumnName(){
	ColumnExpression columnExpression = new ColumnExpression();
	columnExpression.setColumn(column);
	return 	columnExpression;
}){
	return expression;
}
}
void FunctionCall()       :
{}
{
    // caters the following
    // function(args)
    // package.function(args)
    // user.package.function(args)

    // however note that "distinct/all/*" can be only used with
    // inbuilt functions but no distinction is made between inbuilt
    // function and custom functions

    EntityName() [ "." EntityName() ["." EntityName()]]
    "(" ["DISTINCT" | "ALL"] [SQLExpressionList() | "*"] ")"
}


void CastFunctionCall()      :
{}
{
	//Cast funciton in DB2 is very different from all other functions
	"CAST" "(" SQLSimpleExpression() "AS" DataTypes() ")"
}

String FunctionName() :
{
  Token t = null;
}
{
	(t=<K_INSERT>
	| t=<K_MOD>
	| t=<K_MICROSECOND>
	| t=<K_YEAR>
	| t=<K_DAY>
	| t=<K_MINUTE>
	| t=<K_MONTH>
	| t=<K_HOUR>
	| t=<K_SECOND>
	|t=<IDENTIFIER>
	)
	{
		if(t != null){
			return t.image.toUpperCase();
		}else{
			return null;	
		}
	}
}

//This covers all over loaded functions that are using keyword and can not be captured by
//generic function defination
Expression OverloadedFunctionCall()      :
{
	Expression expression = null;
	Function function = null;
	Token functionNameToken = null;
	String functionName = null;
	FunctionExpression funExpression = null;
	boolean nullExp = false;
	
}
{
	functionName = FunctionName(){
		funExpression = new FunctionExpression();
		function = getFunction(functionName);
		funExpression.setFunction(function);
	}
	(["(" [ expression = SQLSimpleExpression(){
			if(funExpression != null){
				if(expression == null){
					nullExp = true;
				}
				funExpression.addArgExpression(expression);
			}
		 }] ("," expression = SQLSimpleExpression(){
			if(funExpression != null){
				if(expression == null){
					nullExp = true;
				}
				funExpression.addArgExpression(expression);
			} 	
		})* ")"]){
			if(nullExp){
				return null;	
			}else{
				return funExpression;
			}
		}	
	
	/**
        ("DATE"{functionName="DATE";} "(" SQLSimpleExpression() ")"
        | "TIME"{functionName="TIME";} "(" SQLSimpleExpression() ")"
        | "TIMESTAMP"{functionName="TIMESTAMP";} "(" SQLSimpleExpression() ["," SQLSimpleExpression() ] ")"
        | "FLOAT"{functionName="FLOAT";} "(" SQLSimpleExpression() ")"
        | "DOUBLE"{functionName="DOUBLE";} "(" SQLSimpleExpression() ")"
        | "INTEGER"{functionName="INTEGER";} "(" SQLSimpleExpression() ")"
        | "INT"{functionName="INT";} "(" SQLSimpleExpression() ")"
        | "DECIMAL"{functionName="DECIMAL";} "(" SQLSimpleExpression() ["," <FLOATING_POINT_LITERAL> ["," <FLOATING_POINT_LITERAL> ["," <FLOATING_POINT_LITERAL>]]] ")"
        | "DEC"{functionName="DEC";} "(" SQLSimpleExpression() ["," <FLOATING_POINT_LITERAL> ["," <FLOATING_POINT_LITERAL> ["," <FLOATING_POINT_LITERAL>]]]  ")"
        | "LEFT"{functionName="LEFT";} "(" SQLSimpleExpression() "," <FLOATING_POINT_LITERAL> ")"
        | "NOW"{functionName="NOW";} "(" [SQLSimpleExpression()] ")"
        | "SYSDATE"{functionName="NOW";} "(" [SQLSimpleExpression()] ")"
        | "RIGHT"{functionName="RIGHT";} "(" SQLSimpleExpression() "," <FLOATING_POINT_LITERAL> ")"
        | "VARCHAR"{functionName="VARCHAR";} "(" SQLSimpleExpression() ["," <FLOATING_POINT_LITERAL>] ")"
        | "CHAR"{functionName="CHAR";} "(" SQLSimpleExpression() ["," <FLOATING_POINT_LITERAL>] ")"
        | "DAY"{functionName="DAY";} "(" SQLSimpleExpression() ")"
        | "DAYS"{functionName="DAYS";} "(" SQLSimpleExpression() ")"
        | "HOUR"{functionName="HOUR";} "(" SQLSimpleExpression() ")"
        | "MICROSECOND"{functionName="MICROSECOND";} "(" SQLSimpleExpression() ")"
        | "MINUTE"{functionName="MINUTE";} "(" SQLSimpleExpression() ")"
        | "MONTH"{functionName="MONTH";} "(" SQLSimpleExpression() ")"
        | "SECOND"{functionName="SECOND";} "(" SQLSimpleExpression() ")"
        | "YEAR"{functionName="YEAR";} "(" SQLSimpleExpression() ")"
        | "CURRENT_TIMESTAMP"{functionName="NOW";}
		| "CURRENT_TIME"{functionName="CURRENT_TIME";}
		| "CURRENT_DATE"{functionName="CURRENT_DATE";}
        | "TO_DATE"{functionName="TO_DATE";} "("expression = SQLSimpleExpression() ")"){
        	function = getFunction(functionName);
        	if(function == null){return null;}
        	FunctionExpression funExpression = new FunctionExpression();
        	funExpression.setFunction(function);
        	if(expression != null){
        		funExpression.addArgExpression(expression);
        	}
        	return funExpression;
        }
        **/
}

void DataTypes()      :
{}
{
    (       "CHAR"
        |   "VARCHAR"
        |   "VARCHAR2"
        |   "DECIMAL"
        |   "INTEGER"
        |   "INT"
        |   "NUMBER"
        |   "NUMERIC"
        |   "REAL"
        |   "FLOAT"
    ) [ "(" <FLOATING_POINT_LITERAL> [ "," <FLOATING_POINT_LITERAL> ] ")" ]

    |   "DATE"
    |   "TIME"
    |   "TIMESTAMP"
    |   "BOOLEAN"
}

void ForUpdateClause() :
{}
{
    "FOR" "UPDATE" ["OF" ColumnName() ("," ColumnName())*] [<K_NOWAIT>]
}

void ReadOnlyClause() :
{}
{
	"FOR" ("FETCH" | "READ") "ONLY"
}

void OptimizeForClause() :
{}
{
	"OPTIMIZE" "FOR" <FLOATING_POINT_LITERAL> (<IDENTIFIER>|<S_COMMA_IDENTIFIER>)

}

void WithClause() :
{}
{
	"WITH" (<IDENTIFIER>|<S_COMMA_IDENTIFIER>) [<IDENTIFIER> <IDENTIFIER> <IDENTIFIER>]
}

void QuerynoClause() :
{}
{
	"QUERYNO" <FLOATING_POINT_LITERAL>
}

void FetchFirstClause() :
{}
{
	"FETCH" <IDENTIFIER> [<FLOATING_POINT_LITERAL>] <IDENTIFIER> "ONLY"
}
